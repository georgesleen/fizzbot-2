use std::collections::HashMap;
use std::env;
use std::fs::File;
use std::io::BufReader;
use std::path::PathBuf;
use std::process::Command;

use serenity::async_trait;
use serenity::model::channel::Message;
use serenity::model::gateway::Ready;
use serenity::prelude::*;

type SpeakerToken = String;

struct Handler;

/// Gets the repository root
///
/// @return the path to the repository root
fn repo_root() -> PathBuf {
    let mut dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    while !dir.join(".git").exists() {
        dir = dir.parent().unwrap().to_path_buf();
    }
    return dir;
}

/// Get the path to the lookup table for user to user token
///
/// @return the path the the lookup table
fn user_lookup_path() -> PathBuf {
    return repo_root()
        .join("llm")
        .join("train_data")
        .join("speaker_map.json");
}

/// Look up the given user in the lookup table generated by training fizzbot
///
/// @param name the user to lookup
fn lookup_user(name: &str) -> Option<SpeakerToken> {
    // Open file in read-oly mode with buffer
    let file = File::open(user_lookup_path()).expect("Failed to open speaker map.");
    let reader = BufReader::new(file);

    let map: HashMap<String, SpeakerToken> = serde_json::from_reader(reader).ok()?;
    return map.get(name).cloned();
}

/// Call fizzbot and return the generated response
///
/// @param name the original author of the message
/// @param content the content of the message
/// @return the response generated by fizzbot
fn generate_response(speaker: SpeakerToken, content: &str) -> Option<String> {
    println!("Generating response...");
    let output = Command::new("make")
        .arg("fizzbot-cpu-once")
        .arg(format!("SPEAKER={}", speaker))
        .arg(format!("CONTENT={}", content))
        .current_dir(repo_root())
        .output()
        .ok()?;

    if !output.status.success() {
        eprintln!(
            "Fizzbot failed: {}",
            String::from_utf8_lossy(&output.stderr)
        );
        return None;
    }

    return Some(String::from_utf8_lossy(&output.stdout).trim().to_string());
}

#[async_trait]
impl EventHandler for Handler {
    // Set a handler for the 'message' event. This is called whenever a new message is recieved.
    //
    // Event handlers are dispatched through a threadpool,
    // so multiple events can be dispatched simultaneously.
    async fn message(&self, context: Context, message: Message) {
        let bot_id = context.cache.current_user().id;

        for mention in &message.mentions {
            if mention.id == bot_id {
                let content = message
                    .content
                    .replace(&format!("<@{}>", bot_id), "")
                    .replace(&format!("<@!{}>", bot_id), "")
                    .trim()
                    .to_string();
                if let Some(speaker) = lookup_user(&message.author.name) {
                    let content = content.clone();

                    let reply =
                        tokio::task::spawn_blocking(move || generate_response(speaker, &content))
                            .await
                            .ok()
                            .flatten();

                    if let Some(reply) = reply {
                        println!("{}", reply);
                        if let Err(why) = message.channel_id.say(&context.http, reply).await {
                            println!("Error sending message: {why:?}");
                        }
                    }
                }
                // Prevent duplicate replies for multiple mentions
                break;
            }
        }
    }

    // Set a handler to be called on the 'ready' event. This is called when a shard is booted, and
    // a READY paylod is sent by Discord. This payload contains data like the current user's guild
    // Ids, current user data, private channels, and more.
    //
    // In this case, just print what the current user's username is.
    async fn ready(&self, _: Context, ready: Ready) {
        println!("{} is connected!", ready.user.name);
    }
}

#[tokio::main]
async fn main() {
    // Configure with bot token environment variable, if no token set load from .env
    dotenvy::dotenv().ok();
    let token = env::var("DISCORD_TOKEN").expect("Expected a token in the environment.");
    // Set gateway intents, which decides what the bot will be notified about
    let intents = GatewayIntents::GUILD_MESSAGES | GatewayIntents::MESSAGE_CONTENT;

    // Create a new instance of the Client, logging in as a bot.
    // This will automatically prepend your bot token with "Bot ",
    // which is a requirement by Discord.
    let mut client = Client::builder(&token, intents)
        .event_handler(Handler)
        .await
        .expect("Error creating client");

    // Finally, start a single shard, and start listening to events.
    //
    // Shards will automatically attempt to reconnect, and will perform exponential backoff until
    // it reconnects.
    if let Err(why) = client.start().await {
        println!("Client error: {why:?}");
    }
}
