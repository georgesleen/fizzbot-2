use std::collections::HashMap;
use std::env;
use std::fs::File;
use std::io::BufReader;
use std::path::PathBuf;
use std::process::Stdio;

use rand::seq::IteratorRandom;
use rand::thread_rng;
use serenity::async_trait;
use serenity::builder::EditMessage;
use serenity::model::channel::Message;
use serenity::model::gateway::Ready;
use serenity::prelude::*;
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::process::{ChildStdin, ChildStdout, Command};
use tokio::sync::{Mutex, Semaphore};

use once_cell::sync::Lazy;

type SpeakerToken = String;

struct Handler;

const PROMPT_MARKER: &str = "--- New Prompt ---";
const END_OF_CONTENT_MARKER: &str = "EOF";

struct FizzbotProcess {
    _child: tokio::process::Child,
    stdin: ChildStdin,
    stdout: ChildStdout,
    buffer: String,
    ready_for_input: bool,
}

impl FizzbotProcess {
    async fn start() -> std::io::Result<Self> {
        let mut child = Command::new("make")
            .arg("fizzbot")
            .current_dir(repo_root())
            .stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::inherit())
            .spawn()?;

        let stdin = child
            .stdin
            .take()
            .ok_or_else(|| std::io::Error::new(std::io::ErrorKind::Other, "stdin missing"))?;
        let stdout = child
            .stdout
            .take()
            .ok_or_else(|| std::io::Error::new(std::io::ErrorKind::Other, "stdout missing"))?;

        let mut proc = Self {
            _child: child,
            stdin,
            stdout,
            buffer: String::new(),
            ready_for_input: false,
        };
        proc.read_until_marker().await?;
        proc.ready_for_input = true;
        Ok(proc)
    }

    async fn read_until_marker(&mut self) -> std::io::Result<String> {
        loop {
            if let Some(index) = self.buffer.find(PROMPT_MARKER) {
                let before = self.buffer[..index].to_string();
                self.buffer.clear();
                return Ok(before);
            }
            let mut chunk = [0u8; 4096];
            let read = self.stdout.read(&mut chunk).await?;
            if read == 0 {
                return Err(std::io::Error::new(
                    std::io::ErrorKind::UnexpectedEof,
                    "Fizzbot process exited",
                ));
            }
            self.buffer
                .push_str(&String::from_utf8_lossy(&chunk[..read]));
        }
    }

    async fn generate_response(
        &mut self,
        speaker: &str,
        content: &str,
    ) -> std::io::Result<Option<String>> {
        if !self.ready_for_input {
            self.read_until_marker().await?;
            self.ready_for_input = true;
        }

        self.stdin
            .write_all(format!("{speaker}\n{content}\n{END_OF_CONTENT_MARKER}").as_bytes())
            .await?;
        self.stdin.flush().await?;
        self.ready_for_input = false;

        let output = self.read_until_marker().await?;
        self.ready_for_input = true;

        let response_lines: Vec<&str> = output
            .lines()
            .map(str::trim)
            .filter(|line| !line.is_empty())
            .filter(|line| !line.starts_with("Speaker ("))
            .filter(|line| !line.starts_with("Content:"))
            .filter(|line| *line != PROMPT_MARKER)
            .collect();
        let response = if response_lines.is_empty() {
            None
        } else {
            Some(response_lines.join("\n"))
        };
        Ok(response)
    }
}

static FIZZBOT_PROCESS: Lazy<Mutex<Option<FizzbotProcess>>> = Lazy::new(|| Mutex::new(None));
static GENERATION_SEMAPHORE: Lazy<Semaphore> = Lazy::new(|| Semaphore::new(1));

/// Gets the repository root
///
/// @return the path to the repository root
fn repo_root() -> PathBuf {
    let mut dir = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
    let fallback = dir.clone();
    while !dir.join(".git").exists() {
        let Some(parent) = dir.parent() else {
            return fallback.parent().map(PathBuf::from).unwrap_or(fallback);
        };
        dir = parent.to_path_buf();
    }
    dir
}

/// Get the path to the lookup table for user to user token
///
/// @return the path the the lookup table
fn user_lookup_path() -> PathBuf {
    return repo_root()
        .join("llm")
        .join("train_data")
        .join("speaker_map.json");
}

/// Look up the given user in the lookup table generated by training fizzbot
///
/// @param name the user to lookup
fn lookup_user(name: &str) -> Option<SpeakerToken> {
    // Open file in read-oly mode with buffer
    let file = File::open(user_lookup_path()).expect("Failed to open speaker map.");
    let reader = BufReader::new(file);

    let map: HashMap<String, SpeakerToken> = serde_json::from_reader(reader).ok()?;
    if let Some(token) = map.get(name) {
        return Some(token.clone());
    }
    let mut rng = thread_rng();
    map.values().choose(&mut rng).cloned()
}

/// Call fizzbot and return the generated response
///
/// @param name the original author of the message
/// @param content the content of the message
/// @return the response generated by fizzbot
async fn generate_response(speaker: SpeakerToken, content: &str) -> Option<String> {
    if content.trim().is_empty() {
        return None;
    }
    println!("Generating response...");
    let mut process = FIZZBOT_PROCESS.lock().await;
    if process.is_none() {
        match FizzbotProcess::start().await {
            Ok(proc) => {
                *process = Some(proc);
            }
            Err(err) => {
                eprintln!("Fizzbot failed to start: {err}");
                return None;
            }
        }
    }

    let proc = process.as_mut()?;
    match proc.generate_response(&speaker, content).await {
        Ok(response) => response,
        Err(err) => {
            eprintln!("Fizzbot failed: {err}");
            None
        }
    }
}

#[async_trait]
impl EventHandler for Handler {
    // Set a handler for the 'message' event. This is called whenever a new message is recieved.
    //
    // Event handlers are dispatched through a threadpool,
    // so multiple events can be dispatched simultaneously.
    async fn message(&self, context: Context, message: Message) {
        let bot_id = context.cache.current_user().id;

        for mention in &message.mentions {
            if mention.id == bot_id {
                let content = message
                    .content
                    .replace(&format!("<@{}>", bot_id), "")
                    .replace(&format!("<@!{}>", bot_id), "")
                    .replace("@", "@ ") // Make it impossible to ping anyone
                    .trim()
                    .to_string();
                if content.is_empty() {
                    break;
                }
                if let Some(speaker) = lookup_user(&message.author.name) {
                    let content = content.clone();

                    let (permit, mut placeholder) = match GENERATION_SEMAPHORE.try_acquire() {
                        Ok(permit) => {
                            let placeholder = message
                                .reply(&context.http, "Generating response...")
                                .await
                                .ok();
                            (permit, placeholder)
                        }
                        Err(_) => {
                            let placeholder = message.reply(&context.http, "Queued...").await.ok();
                            let permit = match GENERATION_SEMAPHORE.acquire().await {
                                Ok(permit) => permit,
                                Err(why) => {
                                    println!("Failed to acquire generation permit: {why:?}");
                                    return;
                                }
                            };
                            (permit, placeholder)
                        }
                    };
                    let _permit = permit;

                    if let Some(ref mut sent) = placeholder {
                        let _ = sent
                            .edit(
                                &context.http,
                                EditMessage::new().content("Generating response..."),
                            )
                            .await;
                    }

                    let reply = generate_response(speaker, &content).await;

                    if let Some(reply) = reply {
                        println!("{}", reply);
                        if let Some(ref mut sent) = placeholder {
                            if let Err(why) = sent
                                .edit(&context.http, EditMessage::new().content(reply))
                                .await
                            {
                                println!("Error editing message: {why:?}");
                            }
                        } else if let Err(why) = message.reply(&context.http, reply).await {
                            println!("Error sending message: {why:?}");
                        }
                    } else if let Some(ref mut sent) = placeholder {
                        if let Err(why) = sent
                            .edit(
                                &context.http,
                                EditMessage::new().content("No response generated."),
                            )
                            .await
                        {
                            println!("Error editing message: {why:?}");
                        }
                    }
                } else {
                    let _ = message
                        .reply(&context.http, "I don't have training data for you yet.")
                        .await;
                }
                // Prevent duplicate replies for multiple mentions
                break;
            }
        }
    }

    // Set a handler to be called on the 'ready' event. This is called when a shard is booted, and
    // a READY paylod is sent by Discord. This payload contains data like the current user's guild
    // Ids, current user data, private channels, and more.
    //
    // In this case, just print what the current user's username is.
    async fn ready(&self, _: Context, ready: Ready) {
        println!("{} is connected!", ready.user.name);
    }
}

#[tokio::main]
async fn main() {
    // Configure with bot token environment variable, if no token set load from .env
    dotenvy::dotenv().ok();
    let token = env::var("DISCORD_TOKEN").expect("Expected a token in the environment.");
    // Set gateway intents, which decides what the bot will be notified about
    let intents = GatewayIntents::GUILD_MESSAGES | GatewayIntents::MESSAGE_CONTENT;

    // Create a new instance of the Client, logging in as a bot.
    // This will automatically prepend your bot token with "Bot ",
    // which is a requirement by Discord.
    let mut client = Client::builder(&token, intents)
        .event_handler(Handler)
        .await
        .expect("Error creating client");

    // Finally, start a single shard, and start listening to events.
    //
    // Shards will automatically attempt to reconnect, and will perform exponential backoff until
    // it reconnects.
    if let Err(why) = client.start().await {
        println!("Client error: {why:?}");
    }
}
